# Decorator Pattern

## 스타비즈

---

- 추상 클래스에서 `Beverage` 정의
- 서브 클래스에서 상세 음료 구현.

### 문제점

- 인기가 증가해가면서 메뉴가 너무 많이 증가하고, 모든 메뉴가 Beverage를 상속함
- 첨가물도 있으며 첨가물이나 가격변동에 따른 대비가 어려움

### 해결책?

- 인스턴스 변수와 슈퍼 클래스 상속으로 관리

**문제점**

1. 첨가물의 가격이 바뀔때마다 코드 수정
2. 새로운 음료가 출시될 경우, 특정 첨가물이 들어가면 안되는 음료가 있을 수 있음.
3. 같은 첨가물을 두번 주문하는 경우

## 고찰

---

- **상속만으로는 무조건 유연하거나 관리하기 좋은 디자인은 아님**
- **구성과 위임으로 실행 중에 행동을 상속하는 방법이 있음**
    - 서브 클래스로 행동을 상속받으면 **컴파일 타임**에 결정됨.
    - 구성으로 객체의 행동을 확장하면 **실행 중에 동적으로 할당**가능.

💡 **OCP(Open-Closed Principle)
클래스는 확장에는 열려있지만 변경에는 닫혀있다.**


## Decorator Pattern

---

**이전까지는 클래스가 너무 많아지거나 적합하지 않은 기능을 추가해야했음.**

첨가물 == 음료의 장식(decorate)

방법

1. `DarkRoast` 객체 생성
2. `Mocha` 객체로 장식
3. `Whip` 객체로 장식
4. `cost()` 메서드 호출.
   첨가물의 가격을 계산하는 일은 **객체에게 위임.**

### 정리

1. 데코레이터의 슈퍼 클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 동일(Beverage)
2. 한 객체를 여러개의 데코레이터로 감싸기
3. 데코레이터는 행동을 위임하는것 말고도 다른 추가 메서드 가능
4. 실행중에 데코레이터 적용 가능

💡 **Decorator Pattern
객체에 추가 요소를 동적으로 더할 수 있음. 서브 클래스를 만들때보다 유연하게 기능확장 가능.**

### 고찰

- `CondimentDecorator`에서 `Beverage` 클래스를 확장 ⇒ 상속아닌가?
    - 상속맞지만 **행동을 물려받는게 아님**
- 이 구조로 실행 중에 **동적으로 결정 가능**

## Java IO 클래스

---

**데코레이터 패턴을 적용한 예**
